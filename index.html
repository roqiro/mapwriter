<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>物件探し手書きマップ (iPad対応・ズーム連動版)</title>
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="物件マップ">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/888/888848.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body, html { height: 100%; margin: 0; overflow: hidden; background: #000; overscroll-behavior: none; }
        #map { height: 100%; width: 100%; z-index: 1; outline: none; -webkit-tap-highlight-color: transparent; }
        
        /* キャンバスのスタイル調整: touch-action: none でブラウザのスクロールを無効化 */
        .canvas-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; /* 地図より上 */
            touch-action: none; /* 重要: ブラウザのデフォルト動作を無効化 */
            pointer-events: none; /* 初期状態はイベントを通す */
        }
        
        .leaflet-container { background: #f0f0f0; }
        
        /* UIパネルはキャンバスよりさらに上 */
        .ui-panel { z-index: 1000; padding-top: env(safe-area-inset-top, 20px); pointer-events: none; }
        /* ボタンなどはイベントを受け取る */
        .ui-panel button, .ui-panel input { pointer-events: auto; }
        
        #property-modal, #config-modal, #auto-register-modal { z-index: 2000; }
        .leaflet-control-attribution { display: none !important; }
        .modal-enter { animation: modalFadeIn 0.2s ease-out; }
        @keyframes modalFadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        button { cursor: pointer; touch-action: manipulation; }
        
        .custom-pin { background: transparent; border: none; }
        .star-btn.active svg { fill: #fbbf24; color: #fbbf24; }
        
        .toolbar-scroll { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
        .toolbar-scroll::-webkit-scrollbar { display: none; }
    </style>
</head>
<body class="bg-gray-100">

    <div class="ui-panel fixed top-0 left-4 right-4 flex flex-col gap-2 mt-4">
        <div class="flex justify-between items-start">
            <div class="flex flex-col gap-2 max-w-full">
                <div class="bg-white/90 backdrop-blur-md p-2 rounded-2xl shadow-xl flex gap-1 md:gap-2 border border-white/20 toolbar-scroll">
                    <button id="btn-move" class="p-3 rounded-xl bg-blue-500 text-white shadow-sm transition-all active:scale-90 flex-shrink-0" title="移動">
                        <i data-lucide="move"></i>
                    </button>
                    
                    <div class="w-px bg-gray-200 mx-1 flex-shrink-0"></div>

                    <!-- ペンツール群 -->
                    <button id="btn-draw-blue" class="p-3 rounded-xl bg-white text-gray-700 border shadow-sm transition-all active:scale-90 flex-shrink-0" title="青ペン">
                        <i data-lucide="pencil" class="text-blue-600"></i>
                    </button>
                    <button id="btn-draw-red" class="p-3 rounded-xl bg-white text-gray-700 border shadow-sm transition-all active:scale-90 flex-shrink-0" title="赤ペン">
                        <i data-lucide="pencil" class="text-red-500"></i>
                    </button>
                    <button id="btn-eraser" class="p-3 rounded-xl bg-white text-gray-700 border shadow-sm transition-all active:scale-90 flex-shrink-0" title="消しゴム (なぞって削除)">
                        <i data-lucide="eraser"></i>
                    </button>

                    <div class="w-px bg-gray-200 mx-1 flex-shrink-0"></div>

                    <button id="btn-marker" class="p-3 rounded-xl bg-white text-gray-700 border shadow-sm transition-all active:scale-90 flex-shrink-0" title="ピンを立てる">
                        <i data-lucide="map-pin"></i>
                    </button>
                    <button id="btn-auto-marker" class="p-3 rounded-xl bg-white text-gray-700 border shadow-sm transition-all active:scale-90 flex-shrink-0" title="住所から登録">
                        <i data-lucide="map-pin-plus"></i>
                    </button>
                    
                    <div class="w-px bg-gray-200 mx-1 flex-shrink-0"></div>
                    
                    <button id="btn-undo" class="p-3 rounded-xl bg-white text-gray-700 border shadow-sm transition-all active:scale-90 flex-shrink-0" title="元に戻す">
                        <i data-lucide="undo-2"></i>
                    </button>
                    <button id="btn-config" class="p-3 rounded-xl bg-white text-gray-700 border shadow-sm transition-all active:scale-90 flex-shrink-0" title="クラウド同期・設定">
                        <i data-lucide="shield-check" class="text-green-600"></i>
                    </button>
                </div>
            </div>
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl flex items-center p-1 w-48 md:w-80 border border-white/20 ml-2">
                <input type="text" id="search-input" placeholder="駅、住所を検索..." class="flex-1 px-4 py-2 bg-transparent outline-none text-sm min-w-0">
                <button id="btn-search" class="p-2 text-gray-500 hover:text-blue-500 flex-shrink-0"><i data-lucide="search"></i></button>
            </div>
        </div>
    </div>

    <div id="map"></div>
    <canvas id="drawing-canvas" class="canvas-overlay"></canvas>

    <!-- Modals -->
    <div id="property-modal" class="fixed inset-0 bg-black/50 hidden flex items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-white rounded-3xl w-full max-w-sm p-6 shadow-2xl modal-enter">
            <h3 id="modal-title" class="text-xl font-bold mb-4 flex items-center gap-2 text-gray-800"><i data-lucide="home" class="text-blue-500"></i> 物件登録</h3>
            <div class="space-y-4">
                <input type="text" id="prop-name" class="w-full px-4 py-3 bg-gray-50 border-0 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none" placeholder="物件名 / メモ">
                
                <div class="flex flex-col gap-2">
                    <label class="text-xs font-bold text-gray-500 ml-1">お気に入り度 (色が変わります)</label>
                    <div class="flex justify-between bg-gray-50 p-2 rounded-xl" id="star-container">
                        <button type="button" class="star-btn p-2 text-gray-300 transition-colors" data-rating="1"><i data-lucide="star"></i></button>
                        <button type="button" class="star-btn p-2 text-gray-300 transition-colors" data-rating="2"><i data-lucide="star"></i></button>
                        <button type="button" class="star-btn p-2 text-gray-300 transition-colors" data-rating="3"><i data-lucide="star"></i></button>
                        <button type="button" class="star-btn p-2 text-gray-300 transition-colors" data-rating="4"><i data-lucide="star"></i></button>
                        <button type="button" class="star-btn p-2 text-gray-300 transition-colors" data-rating="5"><i data-lucide="star"></i></button>
                    </div>
                </div>

                <input type="url" id="prop-url" class="w-full px-4 py-3 bg-gray-50 border-0 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none" placeholder="URL (https://...)">
                <div class="flex gap-2 pt-2">
                    <button id="btn-save-prop" class="flex-1 bg-blue-500 text-white py-4 rounded-xl font-bold shadow-lg shadow-blue-200 active:scale-95 transition-transform">保存</button>
                    <button id="btn-cancel-prop" class="flex-1 bg-gray-100 text-gray-700 py-4 rounded-xl font-bold active:scale-95 transition-transform">閉じる</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Auto Register Modal (New) -->
    <div id="auto-register-modal" class="fixed inset-0 bg-black/50 hidden flex items-center justify-center p-4 backdrop-blur-sm overflow-y-auto">
        <div class="bg-white rounded-3xl w-full max-w-sm p-6 shadow-2xl modal-enter my-auto">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2 text-gray-800"><i data-lucide="map-pin-plus" class="text-blue-500"></i> 住所から登録</h3>
            <p class="text-sm text-gray-500 mb-4">SUUMOなどの住所を貼り付けると、場所を検索してピンを立てます。</p>
            <div class="space-y-4">
                <div class="space-y-1">
                    <label class="text-xs font-bold text-gray-500 ml-1">住所 (必須)</label>
                    <input type="text" id="auto-address" class="w-full px-4 py-3 bg-gray-50 border-0 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例: 東京都新宿区...">
                </div>
                
                <div class="space-y-1">
                    <label class="text-xs font-bold text-gray-500 ml-1">物件名 / メモ</label>
                    <input type="text" id="auto-name" class="w-full px-4 py-3 bg-gray-50 border-0 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none" placeholder="物件名">
                </div>

                <div class="space-y-1">
                    <label class="text-xs font-bold text-gray-500 ml-1">URL (任意)</label>
                    <input type="url" id="auto-url" class="w-full px-4 py-3 bg-gray-50 border-0 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none" placeholder="https://...">
                </div>

                <div class="flex flex-col gap-2">
                    <label class="text-xs font-bold text-gray-500 ml-1">お気に入り度</label>
                    <div class="flex justify-between bg-gray-50 p-2 rounded-xl" id="auto-star-container">
                        <button type="button" class="auto-star-btn p-2 text-gray-300 transition-colors" data-rating="1"><i data-lucide="star"></i></button>
                        <button type="button" class="auto-star-btn p-2 text-gray-300 transition-colors" data-rating="2"><i data-lucide="star"></i></button>
                        <button type="button" class="auto-star-btn p-2 text-gray-300 transition-colors" data-rating="3"><i data-lucide="star"></i></button>
                        <button type="button" class="auto-star-btn p-2 text-gray-300 transition-colors" data-rating="4"><i data-lucide="star"></i></button>
                        <button type="button" class="auto-star-btn p-2 text-gray-300 transition-colors" data-rating="5"><i data-lucide="star"></i></button>
                    </div>
                </div>

                <div class="flex gap-2 pt-2">
                    <button id="btn-do-auto-register" class="flex-1 bg-blue-600 text-white py-4 rounded-xl font-bold shadow-lg shadow-blue-200 active:scale-95 transition-transform">検索して登録</button>
                    <button id="btn-cancel-auto" class="flex-1 bg-gray-100 text-gray-700 py-4 rounded-xl font-bold active:scale-95 transition-transform">閉じる</button>
                </div>
            </div>
        </div>
    </div>

    <div id="config-modal" class="fixed inset-0 bg-black/50 hidden flex items-center justify-center p-4 backdrop-blur-sm overflow-y-auto">
        <div class="bg-white rounded-3xl w-full max-w-md p-6 shadow-2xl modal-enter my-auto">
            <h3 class="text-xl font-bold mb-6 flex items-center gap-2 text-gray-800"><i data-lucide="shield-check" class="text-green-600"></i> 同期設定</h3>
            <div class="space-y-6">
                <div class="bg-gray-50 p-5 rounded-2xl space-y-4 border border-gray-100">
                    <input type="password" id="cloud-password" class="w-full px-4 py-3 bg-white border border-gray-200 rounded-xl outline-none text-sm" placeholder="パスワード(4文字以上)">
                    <button id="btn-cloud-save" class="w-full bg-blue-600 text-white py-3 rounded-xl font-bold flex items-center justify-center gap-2 shadow-md active:scale-95 transition-all">保存してID発行</button>
                    <div id="sync-id-display" class="hidden bg-blue-50 border border-blue-100 p-4 rounded-xl flex items-center justify-between">
                        <span class="text-lg font-mono font-bold text-blue-900 tracking-wider" id="current-sync-id">----</span>
                        <button onclick="copySyncId()" class="text-blue-700 p-2"><i data-lucide="copy" size="20"></i></button>
                    </div>
                    <div class="pt-4 border-t border-gray-200 flex flex-col gap-2">
                        <input type="text" id="sync-id-input" placeholder="共有用ID" class="px-4 py-3 bg-white border border-gray-200 rounded-xl text-sm font-mono uppercase">
                        <button id="btn-cloud-load" class="bg-gray-800 text-white py-3 rounded-xl font-bold active:scale-95 transition-all">読込実行</button>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-2">
                    <button id="btn-export" class="py-3 rounded-xl border text-sm font-medium bg-white">バックアップ</button>
                    <button onclick="document.getElementById('import-file').click()" class="py-3 rounded-xl border text-sm font-medium bg-white">読込</button>
                    <input type="file" id="import-file" class="hidden" accept=".json">
                </div>
                <button id="btn-clear-all" class="w-full text-red-500 text-sm font-medium py-2">すべてのデータを消去</button>
                <button id="btn-close-config" class="w-full bg-gray-100 py-4 rounded-xl font-bold">閉じる</button>
            </div>
        </div>
    </div>

    <div id="loading" class="fixed inset-0 bg-white/80 z-[3000] hidden flex flex-col items-center justify-center gap-4">
        <div class="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
        <p class="text-blue-600 font-bold" id="loading-text">処理中...</p>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        const STORAGE_KEY = 'secure_property_map_v3';
        let map, canvas, ctx, db, auth;
        let mode = 'move';
        let currentColor = '#3b82f6'; // デフォルト青
        let isDrawing = false;
        let currentPath = []; // 緯度経度の配列ではなく、ピクセル座標の一時保存用
        let drawings = [];
        let markers = [];
        let pendingLatLng = null;
        let pendingMarker = null; // 編集中のマーカー
        let currentRating = 3;
        let autoRegisterRating = 3;

        const getFirebaseConfig = () => {
            if (typeof __firebase_config !== 'undefined' && __firebase_config) return JSON.parse(__firebase_config);
            return { apiKey: "YOUR_API_KEY", authDomain: "YOUR_PROJECT.firebaseapp.com", projectId: "YOUR_PROJECT_ID", storageBucket: "YOUR_PROJECT.appspot.com", messagingSenderId: "YOUR_ID", appId: "YOUR_APP_ID" };
        };

        async function encryptData(text, password) {
            const encoder = new TextEncoder();
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const passwordKey = await window.crypto.subtle.importKey("raw", encoder.encode(password), "PBKDF2", false, ["deriveKey"]);
            const key = await window.crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, passwordKey, { name: "AES-GCM", length: 256 }, false, ["encrypt"]);
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoder.encode(text));
            return { data: btoa(String.fromCharCode(...new Uint8Array(encrypted))), iv: btoa(String.fromCharCode(...iv)), salt: btoa(String.fromCharCode(...salt)) };
        }

        async function decryptData(obj, password) {
            const decoder = new TextDecoder();
            const encoder = new TextEncoder();
            const encrypted = new Uint8Array(atob(obj.data).split("").map(c => c.charCodeAt(0)));
            const iv = new Uint8Array(atob(obj.iv).split("").map(c => c.charCodeAt(0)));
            const salt = new Uint8Array(atob(obj.salt).split("").map(c => c.charCodeAt(0)));
            const passwordKey = await window.crypto.subtle.importKey("raw", encoder.encode(password), "PBKDF2", false, ["deriveKey"]);
            const key = await window.crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, passwordKey, { name: "AES-GCM", length: 256 }, false, ["decrypt"]);
            const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encrypted);
            return decoder.decode(decrypted);
        }

        function getWeightForZoom(zoom = map.getZoom()) {
            const base = 1.5; // ペンの太さを調整 (3 -> 1.5)
            let w;
            if (zoom <= 10) w = base * 0.8;
            else if (zoom <= 13) w = base;
            else if (zoom <= 15) w = base * 1.8;
            else if (zoom <= 17) w = base * 3;
            else w = base * 5;
            
            return Math.max(1, w); // 最低1pxは保証
        }

        async function init() {
            setupUI();

            try {
                const config = getFirebaseConfig();
                if (config && config.apiKey !== "YOUR_API_KEY") {
                    const app = initializeApp(config);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) await signInWithCustomToken(auth, __initial_auth_token);
                    else await signInAnonymously(auth);
                }
            } catch (e) { console.warn("Firebase initialization skipped."); }

            map = L.map('map', { 
                zoomControl: false, 
                tap: false, 
                attributionControl: false, 
                touchZoom: true, 
                bounceAtZoomLimits: false 
            }).setView([35.6812, 139.7671], 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            L.control.zoom({ position: 'bottomright' }).addTo(map);

            canvas = document.getElementById('drawing-canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            loadFromLocal();
            
            // iPad/Apple Pencil対応のためのPointer Events実装
            canvas.addEventListener('pointerdown', handlePointerDown, { passive: false });
            canvas.addEventListener('pointermove', handlePointerMove, { passive: false });
            canvas.addEventListener('pointerup', handlePointerUp, { passive: false });
            canvas.addEventListener('pointercancel', handlePointerUp, { passive: false });

            // ★追加: マルチタッチ（2本指以上）検知で移動モードへ自動切替
            canvas.addEventListener('touchstart', (e) => {
                if (mode === 'draw' && e.touches.length >= 2) {
                    // 描画をキャンセル
                    isDrawing = false;
                    currentPath = [];
                    clearCanvas();
                    
                    // 移動モードへ
                    setMode('move');
                    showToast("移動モードに切り替えました");
                }
            }, { passive: true });

            map.on('zoomend', () => {
                const newWeight = getWeightForZoom();
                drawings.forEach(d => d.instance.setStyle({ weight: newWeight }));
            });

            // マーカー配置モード用
            map.on('click', (e) => {
                if (mode === 'marker') {
                    pendingLatLng = e.latlng;
                    pendingMarker = null; // 新規作成なので編集対象はnull
                    resetRating(); 
                    document.getElementById('modal-title').innerHTML = '<i data-lucide="home" class="text-blue-500"></i> 物件登録';
                    document.getElementById('property-modal').classList.remove('hidden');
                    lucide.createIcons();
                }
            });
            
            lucide.createIcons();
            setMode('move'); // 初期モード
        }

        // --- Pointer Event Handlers for Drawing ---
        function handlePointerDown(e) {
            if (mode !== 'draw' && mode !== 'eraser') return;

            // ペン入力(pen)の場合は、isPrimaryに関わらず描画を許可する。
            // これにより、手が触れていてもペンの反応が優先され、2画目以降の取りこぼしが減る。
            const isPen = e.pointerType === 'pen';
            
            // 指入力の場合は、マルチタッチ誤爆防止のためisPrimaryのみ許可。
            if (!isPen && !e.isPrimary) return; 

            e.preventDefault(); 
            isDrawing = true;
            
            // ポインターキャプチャを設定して、高速な描画でのイベント漏れを防ぐ
            canvas.setPointerCapture(e.pointerId);
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (mode === 'eraser') {
                eraseAt(x, y);
            } else {
                currentPath = [{x, y}];
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = getWeightForZoom();
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
            }
        }

        function handlePointerMove(e) {
            if (!isDrawing || (mode !== 'draw' && mode !== 'eraser')) return;
            
            // ペンなら許可、指ならPrimaryのみ
            const isPen = e.pointerType === 'pen';
            if (!isPen && !e.isPrimary) return; 

            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (mode === 'eraser') {
                eraseAt(x, y);
            } else {
                currentPath.push({x, y});
                ctx.lineTo(x, y);
                ctx.stroke();
            }
        }

        function handlePointerUp(e) {
            if (!isDrawing || (mode !== 'draw' && mode !== 'eraser')) return;
            
            // ペンなら許可、指ならPrimaryのみ
            const isPen = e.pointerType === 'pen';
            if (!isPen && !e.isPrimary) return; 

            e.preventDefault();
            isDrawing = false;
            
            // キャプチャ解放（安全のため）
            if (canvas.hasPointerCapture(e.pointerId)) {
                canvas.releasePointerCapture(e.pointerId);
            }
            
            if (mode === 'draw' && currentPath.length > 1) {
                const latLngs = currentPath.map(p => map.containerPointToLatLng([p.x, p.y]));
                createPolyline(latLngs, currentColor);
                saveToLocalDebounced(); // 即時保存ではなくデバウンス保存
            }
            clearCanvas();
            currentPath = [];
        }

        function eraseAt(x, y) {
            const threshold = 25; 
            let changed = false;

            for (let i = drawings.length - 1; i >= 0; i--) {
                const d = drawings[i];
                const latLngs = d.instance.getLatLngs();
                
                let hit = false;
                for (const ll of latLngs) {
                    const p = map.latLngToContainerPoint(ll);
                    if (Math.hypot(p.x - x, p.y - y) < threshold) {
                        hit = true;
                        break;
                    }
                }

                if (hit) {
                    map.removeLayer(d.instance);
                    drawings.splice(i, 1);
                    changed = true;
                    
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(x, y, threshold, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            for (let i = markers.length - 1; i >= 0; i--) {
                const m = markers[i];
                const p = map.latLngToContainerPoint(m.latlng);
                if (Math.hypot(p.x - x, p.y - 40 + 20) < 40) {
                    map.removeLayer(m.instance);
                    markers.splice(i, 1);
                    changed = true;
                }
            }

            if (changed) {
                saveToLocalDebounced();
            }
        }

        function createPolyline(path, color) {
            const polyline = L.polyline(path, { 
                color: color, 
                weight: getWeightForZoom(), 
                opacity: 0.8, 
                lineJoin: 'round', 
                lineCap: 'round',
                className: 'drawable-path' 
            }).addTo(map);

            polyline.on('click', (e) => {
                if (mode === 'eraser') {
                    L.DomEvent.stopPropagation(e);
                    removeDrawing(polyline);
                }
            });

            drawings.push({ instance: polyline, color: color });
            return polyline;
        }

        function removeDrawing(polylineInstance) {
            map.removeLayer(polylineInstance);
            drawings = drawings.filter(d => d.instance !== polylineInstance);
            saveToLocalDebounced();
        }

        function resizeCanvas() { if (canvas) { canvas.width = window.innerWidth; canvas.height = window.innerHeight; } }

        function setupUI() {
            const elements = {
                'btn-move': () => setMode('move'),
                'btn-draw-blue': () => setMode('draw', '#3b82f6'),
                'btn-draw-red': () => setMode('draw', '#ef4444'),
                'btn-eraser': () => setMode('eraser'),
                'btn-marker': () => setMode('marker'),
                'btn-auto-marker': openAutoRegisterModal,
                'btn-undo': undoLastAction,
                'btn-config': () => document.getElementById('config-modal').classList.remove('hidden'),
                'btn-close-config': () => document.getElementById('config-modal').classList.add('hidden'),
                'btn-clear-all': clearAll,
                'btn-export': exportData,
                'btn-cloud-save': cloudSave,
                'btn-cloud-load': cloudLoad,
                'btn-cancel-prop': () => document.getElementById('property-modal').classList.add('hidden'),
                'btn-save-prop': saveMarker,
                'btn-cancel-auto': () => document.getElementById('auto-register-modal').classList.add('hidden'),
                'btn-do-auto-register': doAutoRegister,
                'btn-search': search
            };

            for (const [id, action] of Object.entries(elements)) {
                const el = document.getElementById(id);
                if (el) el.onclick = action;
            }

            document.querySelectorAll('.star-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const r = parseInt(e.currentTarget.dataset.rating);
                    setRating(r);
                };
            });
            
            // Auto Register Star Buttons
            document.querySelectorAll('.auto-star-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const r = parseInt(e.currentTarget.dataset.rating);
                    setAutoRegisterRating(r);
                };
            });

            const importFile = document.getElementById('import-file');
            if (importFile) {
                importFile.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (ev) => { applyMapData(JSON.parse(ev.target.result)); saveToLocal(); };
                    reader.readAsText(file);
                };
            }
        }

        function setRating(r) {
            currentRating = r;
            document.querySelectorAll('.star-btn').forEach(btn => {
                const btnR = parseInt(btn.dataset.rating);
                if (btnR <= r) btn.classList.add('active');
                else btn.classList.remove('active');
            });
        }
        
        function setAutoRegisterRating(r) {
            autoRegisterRating = r;
            document.querySelectorAll('.auto-star-btn').forEach(btn => {
                const btnR = parseInt(btn.dataset.rating);
                if (btnR <= r) btn.classList.add('active');
                else btn.classList.remove('active');
            });
        }

        function resetRating() { setRating(3); }

        function setMode(m, color = null) {
            mode = m;
            if (color) currentColor = color;

            const btns = ['btn-move', 'btn-draw-blue', 'btn-draw-red', 'btn-eraser', 'btn-marker', 'btn-auto-marker'];
            btns.forEach(id => {
                const btn = document.getElementById(id);
                if (!btn) return;
                
                let isActive = false;
                if (m === 'draw') {
                    if (id === 'btn-draw-blue' && currentColor === '#3b82f6') isActive = true;
                    if (id === 'btn-draw-red' && currentColor === '#ef4444') isActive = true;
                } else if (id === `btn-${m}`) {
                    isActive = true;
                }
                
                if (id === 'btn-auto-marker') isActive = false;

                if (isActive) {
                    btn.classList.add('bg-blue-500', 'text-white');
                    btn.classList.remove('bg-white', 'text-gray-700');
                    if (id === 'btn-draw-red') {
                        btn.classList.remove('bg-blue-500');
                        btn.classList.add('bg-red-500');
                    }
                    if (id === 'btn-eraser') {
                        btn.classList.remove('bg-blue-500');
                        btn.classList.add('bg-gray-700');
                    }
                } else {
                    btn.classList.remove('bg-blue-500', 'bg-red-500', 'bg-gray-700', 'text-white');
                    btn.classList.add('bg-white', 'text-gray-700');
                }
            });

            if (mode === 'draw' || mode === 'eraser') {
                canvas.style.pointerEvents = 'auto'; 
                
                if (mode === 'eraser') {
                    document.getElementById('map').style.cursor = 'cell'; 
                } else {
                    document.getElementById('map').style.cursor = 'crosshair';
                }
            } else {
                canvas.style.pointerEvents = 'none'; 
                document.getElementById('map').style.cursor = 'grab';
            }
        }

        function drawTempPath() {}

        function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

        function saveMarker() {
            const name = document.getElementById('prop-name').value || '無題の物件';
            const url = document.getElementById('prop-url').value;
            
            if (pendingMarker) {
                // 既存マーカーの更新
                pendingMarker.name = name;
                pendingMarker.url = url;
                pendingMarker.rating = currentRating;
                
                // アイコンとポップアップの更新
                pendingMarker.instance.setIcon(getPinIcon(currentRating));
                const newPopupContent = generatePopupContent(pendingMarker.latlng, name, url, currentRating);
                pendingMarker.instance.setPopupContent(newPopupContent);
                
                saveToLocal(); // マーカー登録は頻度が低いので即時保存でOK
                pendingMarker = null; // リセット
            } else if (pendingLatLng) {
                // 新規マーカーの作成
                const marker = createMarker(pendingLatLng, name, url, currentRating);
                markers.push({ latlng: pendingLatLng, name, url, rating: currentRating, instance: marker });
                saveToLocal(); // マーカー登録は即時保存
            }
            
            document.getElementById('property-modal').classList.add('hidden');
            document.getElementById('prop-name').value = ''; document.getElementById('prop-url').value = '';
            setMode('move');
        }
        
        function openAutoRegisterModal() {
            document.getElementById('auto-address').value = '';
            document.getElementById('auto-name').value = '';
            document.getElementById('auto-url').value = '';
            setAutoRegisterRating(3);
            document.getElementById('auto-register-modal').classList.remove('hidden');
            lucide.createIcons();
        }
        
        async function doAutoRegister() {
            const address = document.getElementById('auto-address').value;
            const name = document.getElementById('auto-name').value || '登録物件';
            const url = document.getElementById('auto-url').value;
            const rating = autoRegisterRating;
            
            if (!address) {
                showToast("住所を入力してください");
                return;
            }
            
            document.getElementById('loading').classList.remove('hidden');
            
            try {
                const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
                const d = await res.json();
                
                if (d && d.length > 0) {
                    const place = d[0];
                    const latlng = L.latLng(place.lat, place.lon);
                    
                    const marker = createMarker(latlng, name, url, rating);
                    markers.push({ latlng: latlng, name, url, rating, instance: marker });
                    saveToLocal(); // 自動登録も即時保存
                    
                    map.setView(latlng, 17);
                    
                    document.getElementById('auto-register-modal').classList.add('hidden');
                    showToast("ピンを登録しました！");
                } else {
                    showToast("住所が見つかりませんでした");
                }
            } catch(e) {
                console.error(e);
                showToast("エラーが発生しました");
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }

        function getPinIcon(rating) {
            const colors = { 1: '#bfdbfe', 2: '#60a5fa', 3: '#2563eb', 4: '#1e40af', 5: '#172554' };
            const c = colors[rating] || colors[3];
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="${c}" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.3));"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3" fill="white"/></svg>`;
            return L.divIcon({ className: 'custom-pin', html: svg, iconSize: [40, 40], iconAnchor: [20, 40], popupAnchor: [0, -40] });
        }
        
        function generatePopupContent(latlng, name, url, rating) {
            const stars = "★".repeat(rating) + "☆".repeat(5 - rating);
            return `
                <div class="p-2 min-w-[160px]">
                    <h4 class="font-bold text-gray-800 border-b pb-1 mb-2 text-base">${name}</h4>
                    <div class="text-yellow-500 text-sm mb-3 tracking-widest">${stars}</div>
                    ${url ? `<a href="${url}" target="_blank" class="text-blue-500 text-sm flex items-center gap-1 mb-3"><i data-lucide="external-link" size="14"></i> 物件詳細</a>` : '<p class="text-xs text-gray-400 mb-3">URLなし</p>'}
                    <div class="flex gap-2">
                        <button onclick="window.editMarker('${latlng.lat}', '${latlng.lng}')" class="flex-1 text-center py-1.5 bg-gray-100 text-gray-700 text-xs rounded hover:bg-gray-200 transition-colors font-bold">編集</button>
                        <button onclick="window.removeAt('${latlng.lat}', '${latlng.lng}')" class="flex-1 text-center py-1.5 bg-red-50 text-red-500 text-xs rounded hover:bg-red-100 transition-colors font-bold">削除</button>
                    </div>
                </div>`;
        }

        function createMarker(latlng, name, url, rating = 3) {
            const popup = generatePopupContent(latlng, name, url, rating);
            const m = L.marker(latlng, { icon: getPinIcon(rating) }).addTo(map).bindPopup(popup);
            m.on('popupopen', () => lucide.createIcons());
            
            m.on('click', (e) => {
                if (mode === 'eraser') {
                    e.target.closePopup();
                    e.originalEvent.preventDefault();
                    e.originalEvent.stopPropagation();
                    window.removeAt(latlng.lat, latlng.lng);
                }
            });

            return m;
        }
        
        window.editMarker = (lat, lng) => {
            const target = markers.find(m => m.latlng.lat == lat && m.latlng.lng == lng);
            if (!target) return;
            
            pendingMarker = target; // 編集対象を保存
            
            // モーダルに現在の値をセット
            document.getElementById('prop-name').value = target.name;
            document.getElementById('prop-url').value = target.url || '';
            setRating(target.rating || 3);
            
            // モーダル表示
            document.getElementById('modal-title').innerHTML = '<i data-lucide="edit" class="text-blue-500"></i> 物件情報の編集';
            document.getElementById('property-modal').classList.remove('hidden');
            lucide.createIcons();
            
            // ポップアップを閉じる
            map.closePopup();
        };

        window.removeAt = (lat, lng) => {
            const idx = markers.findIndex(m => m.latlng.lat == lat && m.latlng.lng == lng);
            if (idx > -1) { map.removeLayer(markers[idx].instance); markers.splice(idx, 1); saveToLocal(); }
        };

        async function search() {
            const q = document.getElementById('search-input').value;
            if (!q) return;
            try {
                const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
                const d = await res.json();
                if (d && d.length > 0) {
                    const place = d[0];
                    if (place.boundingbox) {
                        const southWest = [place.boundingbox[0], place.boundingbox[2]];
                        const northEast = [place.boundingbox[1], place.boundingbox[3]];
                        map.fitBounds([southWest, northEast], { padding: [50, 50] });
                    } else {
                        map.setView([place.lat, place.lon], 17);
                    }
                } else {
                    showToast("場所が見つかりませんでした");
                }
            } catch (e) {
                console.error(e);
                showToast("検索中にエラーが発生しました");
            }
        }

        function undoLastAction() { 
            if (drawings.length > 0) { 
                const last = drawings.pop();
                map.removeLayer(last.instance); 
                saveToLocal(); // Undoは頻度が低いので即時保存
            } 
        }

        function clearAll() {
            if (!confirm("すべて削除しますか？")) return;
            drawings.forEach(d => map.removeLayer(d.instance)); markers.forEach(m => map.removeLayer(m.instance));
            drawings = []; markers = []; saveToLocal();
            document.getElementById('config-modal').classList.add('hidden');
        }

        function getMapState() { 
            return { 
                drawings: drawings.map(d => ({ latlngs: d.instance.getLatLngs(), color: d.color })), 
                markers: markers.map(m => ({ latlng: m.latlng, name: m.name, url: m.url, rating: m.rating })), 
                center: map.getCenter(), 
                zoom: map.getZoom() 
            }; 
        }

        function applyMapData(data) {
            if (!data) return;
            drawings.forEach(d => map.removeLayer(d.instance)); markers.forEach(m => map.removeLayer(m.instance));
            drawings = []; markers = [];
            if (data.center) map.setView(data.center, data.zoom);
            
            if (data.drawings) {
                data.drawings.forEach(d => {
                    const path = Array.isArray(d) ? d : d.latlngs;
                    const color = d.color || '#3b82f6';
                    createPolyline(path, color);
                });
            }
            if (data.markers) data.markers.forEach(m => markers.push({ ...m, instance: createMarker(m.latlng, m.name, m.url, m.rating) }));
        }

        let saveTimeout = null;
        // デバウンス保存: 連続して呼び出されても、最後の呼び出しから1秒後に1回だけ実行する
        function saveToLocalDebounced() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                saveToLocal();
                saveTimeout = null;
            }, 1000); // 1秒間操作がなければ保存
        }

        function saveToLocal() { 
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(getMapState())); 
                // 保存完了の小さなフィードバックがあってもいいかもしれないが、今回はシンプルに
            } catch (e) {
                console.error("Save failed", e);
                // 容量オーバーなどのエラーハンドリング
            }
        }
        
        function loadFromLocal() { const saved = localStorage.getItem(STORAGE_KEY); if (saved) applyMapData(JSON.parse(saved)); }

        function exportData() {
            const blob = new Blob([JSON.stringify(getMapState())], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `map_backup.json`; a.click();
        }

        async function cloudSave() {
            const pw = document.getElementById('cloud-password').value;
            if (!pw || pw.length < 4) return showToast("4文字以上のパスワードを設定してください");
            if (!db) return showToast("クラウド設定が必要です");
            document.getElementById('loading').classList.remove('hidden');
            try {
                const encrypted = await encryptData(JSON.stringify(getMapState()), pw);
                const syncId = Math.random().toString(36).substring(2, 10).toUpperCase();
                const aid = typeof __app_id !== 'undefined' ? __app_id : 'my-property-map';
                await setDoc(doc(db, 'artifacts', aid, 'public', 'data', 'sharedMaps', syncId), { encryptedData: encrypted, createdAt: Date.now(), secure: true });
                document.getElementById('sync-id-display').classList.remove('hidden');
                document.getElementById('current-sync-id').textContent = syncId;
                showToast("暗号化保存成功");
            } catch (e) { showToast("保存失敗"); } finally { document.getElementById('loading').classList.add('hidden'); }
        }

        async function cloudLoad() {
            const id = document.getElementById('sync-id-input').value.trim().toUpperCase();
            const pw = document.getElementById('cloud-password').value;
            if (!id || !pw) return showToast("IDとパスワードが必要です");
            if (!db) return showToast("クラウド設定が必要です");
            document.getElementById('loading').classList.remove('hidden');
            try {
                const aid = typeof __app_id !== 'undefined' ? __app_id : 'my-property-map';
                const snap = await getDoc(doc(db, 'artifacts', aid, 'public', 'data', 'sharedMaps', id));
                if (snap.exists()) {
                    const decrypted = await decryptData(snap.data().encryptedData, pw);
                    applyMapData(JSON.parse(decrypted)); saveToLocal();
                    showToast("同期完了"); document.getElementById('config-modal').classList.add('hidden');
                } else { showToast("ID不正"); }
            } catch (e) { showToast("解読失敗"); } finally { document.getElementById('loading').classList.add('hidden'); }
        }

        window.copySyncId = () => {
            const id = document.getElementById('current-sync-id').textContent;
            navigator.clipboard.writeText(id).then(() => showToast("コピーしました"));
        };

        function showToast(msg) {
            const t = document.createElement('div');
            t.className = 'fixed bottom-24 left-1/2 -translate-x-1/2 bg-gray-900 text-white px-6 py-3 rounded-2xl text-sm z-[4000] shadow-2xl transition-all';
            t.textContent = msg; document.body.appendChild(t);
            setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 500); }, 3000);
        }

        init();
    </script>
</body>
</html>
